* Review of Client & Server Javascript
So before we get into our final projects for this course, let's go ahead and review the basics of how to use Javascript for both server-side and client-side programming. We'll be going through a series of small examples, building up on themselves until we eventually have a small application with enough features to flex our new-found muscle. There will be suggested exercises throughout giving ideas for how to modify the examples or writing your own applications. 
** Core Ideas
   So first let us discuss what the major ideas of what we've covered since leaving the basics of the javascript language. Basically, we've gone from a world that consists only of javascript code existing in a vaccuum that can, occasionally, print things to the output we're now considering javascript as a part of an ecosystem for web development. 

   The two main components for any application deployed over the network, web app or otherwise, are
   + the client code
   + the server code
where the client handles the display of data and controlling the user interface to the application and the server code handles the real /logic/ of the application: the way data is stored and retrieved, what users can access what functionality, and keeping everything synced between the various clients.

In the case of the programs we're dealing with, both the client and server are going to be written in Javascript. Both sides don't have to be written in the same language, and I dare say that the most common case is that they are /not/. One of the reasons, I think, for Node's popularity is that you can take your skills in javascript for client side programming and use them for server side programming as well. It's an understandably nice feature. On the other hand, I think it might make the distinction between client and server unclear to newcomers! In this review I'll be attempting to elucidate where the different bits of code are running: the client's browser or a server process. A general rule of thumb, though, is that if the code is making the HTML interactive in some way then it must be running in the client browser and otherwise it is probably running on the server. Yes, even most templating like we've seen in Express is actually server-side code that /generates/ HTML rather than scripts that are included in the browser along /with/ the HTML.

We're not really making the Model-View-Controller distinction here, per se, but it shows up a little bit in terms of how we'll eventually refactor things a bit.

We'll more or less follow the progression
** Our First Node Server
Our very first Node server is going to be rather simple: it'll be a kind of "echo" server that will spit back out to the client "You said: message-from-client". This is shockingly simple when it comes to Node and so let's just include the code below:

#+BEGIN_SRC js :exports code :tangle FirstServer.js
  var http = require('http');

  var server = http.createServer(function (req,res) {
      res.writeHead(200, {'Content-Type' : 'text/plain'});
      var msg = "";
      req.on('data', function (chunk) {
          msg = msg + chunk.toString();
      });
      req.on('end', function () {
          res.write("You said: " + msg);
          res.end();
      })
  });

  server.listen(3000);

  console.log("Listening on port 3000\n");
#+END_SRC

Now let's talk about what this actually means piece by piece. The first thing is that we need to include the HTTP library in line 1 when we say ~var http = require('http')~. The next important line is that we actually create our server using the HTTP library function ~http.createServer~. This might be a good time to review that when we make a module with ~require~ we're actually returning the value of ~module.exports~, which is often but not always an object, so we're actually accessing the functions of the libraries as methods of the object created by the ~require~ statement. 

Here, we give ~http.createServer~ a single argument: a callback. This callback itself takes two arguments: the incoming request object and the pre-made response object that will be fed back to the client. Under the hood, node is going to build an object of the class ~http.IncomingMessage~ that holds the data for the request and an object of the class ~http.ServerResponse~ that will hold the response to be sent back to the server and then passes those to the callback. You don't particularly need to know what happens under the hood, I don't really know what the code looks like under the hood, but that's the point of a library: you interact with the interface not the implementation.

This wasn't the only way we could write this function, though. For example, since ~http.createServer~ returns an /object/ then we could have collapsed a couple of those lines together with "method chaining" and instead said

#+BEGIN_SRC js :exports code :tangle FirstServer-2.js
  var http = require('http');

  http.createServer(function (req,res) {
      res.writeHead(200, {'Content-Type' : 'text/plain'});
      var msg = "";
      req.on('data', function (chunk) {
          msg = msg + chunk.toString();
      });
      req.on('end', function () {
          res.write("You said: " + msg);
          res.end();
      });
  }).listen(3000);

  console.log("Listening on port 3000\n");
#+END_SRC

We could also simplify things a bit by combining the ~write~ and ~end~ into one step and using method chaining on the ~req~ to assign multiple event handlers at once so then we get

#+BEGIN_SRC js :exports code :tangle FirstServer-3.js
  var http = require('http');

  http.createServer(function (req,res) {
      res.writeHead(200, {'Content-Type' : 'text/plain'});
      var msg = "";
      req.on('data', function (chunk) {
          msg = msg + chunk.toString();
      }).on('end', function () {
          res.end("You said: " + msg);
      });
  }).listen(3000, function () {
      console.log("Listening on port 3000\n");
  });
#+END_SRC

Beyond that, I'm not sure if there's really good ways to make it simpler without potentially just making it harder to read. 

** A More Complicated Node Server
Now let's try building our way up into a more complete server that can handle a small "microblogging" style service, except we'll only be dealing with a single user just to simplify everything at first. 
*** Handling Requests
Our first lesson in making a more complicated server is how to deal with proper HTTP requests from the client. To review briefly, there are four major request methods that you'll need to deal with

   + GET, which is the basic request your browser makes whenever it loads a webpage. This is the request method that represents /get/ting data from the server for display. A simple GET shouldn't modify anything
   + POST, which is the main method for creating new data and often the method used by forms
   + PUT, which is similar to POST but semantically it's for creating /or/ updating data as opposed to creation only
   + DELETE, which unsurprisingly signals that data should be deleted

in order to handle these request methods in just plain node, we simply need to dispatch over the method of the request. Let's try a simple server to demonstrate this

#+BEGIN_SRC js :exports code :tangle SimpleMethods.js
  var http = require('http');

  http.createServer(function (req,res){
      var method = req.method;
      if (method === "POST") {
          res.end("It was a POST");
      }
      else if(method === "PUT"){
          res.end("Puttin'");
      }
      else if(method === "GET") {
          res.end("Go Getter");
      }
      else if(method === "DELETE") {
          res.end("The end of all things");
      }
      else {
          res.end("Something other than the four we discussed")
      }
  }).listen(3000, function () {
      console.log("Listening on port 3000\n");
  });
#+END_SRC

This is a very simple and perhaps silly example, but this is the basic structure of how we respond to different types of requests.

The other skill we need to brush up on is how to dispatch over the url of the site, which we can do with using the url library in node in order to parse the url into pieces. The first thing we'll do is just make sure that we handle displaying the posts if we make a get request to the root.

#+BEGIN_SRC js :exports code :tangle UrlDispatch.js
  var http = require('http');
  var url = require('url');

  http.createServer(function (req,res) {
      var urlObj = url.parse(req.url,true);
      var urlPaths = urlObj.path.slice(1).split('/');
      if (urlPaths[0] === "thing") {
          res.end("That was a thing");
      }
      else if(urlPaths[0] === "stuff") {
          res.end("Here's some stuff")
      }
  }).listen(3000, function () {
      console.log("Listening on port 3000\n")
  });
#+END_SRC

The actual structure of the object that ~url.parse~ returns is given here: http://nodejs.org/docs/latest/api/url.html The main thing we need to pay attention to here is that the ~.path~ property will give us, as a string, the rest of the url after the actual domain so for example "http://mythingy.io/stuff/thing" then ~.path~ will give us the string "/stuff/thing" and we can thus pop off the first "/" with a ~.slice(1)~ and then break it into an array with ~.split('/')~. 

So let's go ahead and try to take a first stab at our microblogging site. We'll be doing some very, very simple HTML generation that will look awful but hopefully be at least renderable. 

To start with we'll just try to display the result of our GET at the root
#+BEGIN_SRC js :exports code :tangle MicroBlog-1.js
  var http = require('http');
  var url = require('url');

  var posts = ["stuff","more stuff", "many tiny posts"];

  http.createServer(function (req,res){
      var method = req.method;
      var urlObj = url.parse(req.url,true);
      var urlPath = urlObj.path.slice(1).split('/')[0];
      if (method === "GET" && urlPath==="") {
          res.writeHead(200,{"Content-Type" : "text/html"})
          res.write("<ul>");
          for(var p = 0; p < posts.length; p++){
              res.write("<li>" + posts[p] + "</li>");
          }
          res.write("</ul>");
          res.end();
      }
      else {
          res.end("Not a supported request");
      }
  }).listen(3000, function () {
      console.log("Listening on port 3000\n");
  });
#+END_SRC

Go ahead and try running the server and seeing what happens if you navigate to localhost:3000. It should display the simple little html that we've written.

Now, let's go ahead and try to write a version of the server that can handle taking in input as well. We'll also, in this case, be using hogan.js in order to do some templating and making this a little bit easier. Note that we'll be using straight-up hogan for templating and /not/ using it as middle-ware because I want to demystify what's happening with these template engines a little bit.

So first before you actually try running anything you'll need to type this in your command line

#+BEGIN_SRC sh :exports code
  npm install hogan.js
#+END_SRC

#+RESULTS:
| hogan.js@3.0.2 | node_modules/hogan.js |                |
| ├──            | mkdirp@0.3.0          |                |
| └──            | nopt@1.0.10           | (abbrev@1.0.5) |

Okay, so first we'll make a hogan template file for displaying posts that will also have a form that will let us add a post and then we'll handle that as well.

#+BEGIN_SRC html :exports code :tangle posts-1.html
  <!DOCTYPE html>
  <html lang="en">
  <body>
    <h1>Make Post</h1>
    <form action="/addpost" method="post">
      <input name="post" placeholder="Say something" type="text" maxlength="140">
      <button type="submit">Post</button>
    </form>
    <h1>Posts</h1>
    <ul>
      {{#posts}}
      <li>{{.}}</li>
      {{/posts}}
    </ul>
  </body>
  </html>
#+END_SRC

#+BEGIN_SRC js :exports code :tangle MicroBlog-2.js
  var http = require('http');
  var url = require('url');
  var fs = require('fs');
  var hogan = require('hogan.js');

  var templateFile = fs.readFileSync('posts-1.html');
  var template = hogan.compile(templateFile);

  var posts = [];

  http.createServer(function (req,res) {
      var method = req.method;
      var urlObj = url.parse(req.url,true);
      var urlPath = urlObj.path.slice(1).split('/')[0];

      if(method === "GET" && urlPath===""){
          template.render({posts : posts});
      }
      else if (method === "POST" && urlPath ==="addpost") {
          var tempPost = "";
          req.on("data", function (chunk) {
              
          });
          req.on("end", function () {
          });
      }
  }).listen(3000, function () {
      console.log("Listening on port 3000\n")
  });

#+END_SRC

*** Making Data Persistent with Files
*** Making Data Persistent with Orchestrate
** Our First Express Server
*** An Aside: package.json
    As we add more complicated functionality to our servers we'll need to add libraries, this means that we'll have our ~package.json~ file that we need to run in our directory before we actually try running our files.

** A Microblogging Express Server
*** Adding a Real Interface: html forms
** JQuery and the Rise of the Dom
*** Finding Elements in JQuery
*** Changing Classes
*** Event Handling
** Microblog Redux
Now we're going to move away from using html forms the old fashion way with http actions and, instead, rely entirely on javascript code to make our buttons and all that work without forcing any page reloads. 
*** One Last Thing: History API 


